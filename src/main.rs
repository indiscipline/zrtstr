// TODO:
// * IEEE Float support
// * Tests
// * Refactor copy_to_mono nestiness.

extern crate hound;
extern crate itertools;
extern crate pbr;
#[macro_use]
extern crate clap;

use std::path::Path;
use std::fs::{remove_file, read_dir};
use std::env;
use hound::{WavReader, WavSpec, WavWriter, SampleFormat};
use itertools::Itertools;
use pbr::ProgressBar;
use clap::{Arg, App};

struct Conf {
    dither: u32,
    dry_run: bool,
    no_overwrites: bool,
}

static LICENSE: &'static str = "zrtstr licensed under GNU General Public License version 2 or later;
Full License available at <http://gnu.org/licenses/gpl.html>.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.";

fn main() {
    let matches = App::new("zrtstr")
            .author(crate_authors!())
            .version(crate_version!())
            .about("Check stereo WAV-file for identical channels, detecting \
                    faux-stereo files generated by some audio-editing software and \
                    DAWs.\nOutputs a true-mono WAV file on detection of \
                    faux-stereo. Takes left channel of the input file, writes in the \
                    same location with -MONO suffix in file name.")
            .arg(Arg::with_name("INPUT")
                    .help("Path to the input file to process. If no input given, \
                    process all WAV files in current directory.")
                    .index(1)
                    .validator(validate_path))
            .arg(Arg::with_name("dither")
                    .short("d")
                    .long("dither")
                    .value_name("THRESHOLD")
                    .required(false)
                    .help("Set threshold for sample level difference to process \
                            dithered audio.{n}Positive number (amplitude delta).")
                    .next_line_help(true)
                    .takes_value(true)
                    .default_value("10")
                    .validator(validate_u32))
            .arg(Arg::with_name("license")
                    .short("l")
                    .long("license")
                    .help("Display the license information."))
            .arg(Arg::with_name("dry_run")
                    .short("n")
                    .long("nowrite")
                    .help("Disable saving converted mono files. Analyze pass only.")
                    .required(false))
            .arg(Arg::with_name("no_overwrites")
                    .short("p")
                    .long("protect")
                    .help("Disable overwriting when saving converted mono files.")
                    .required(false))
            .get_matches();

    if matches.is_present("license") {
        println!("{}", LICENSE);
        println!("\nclap (Command Line Argument Parser) License:");
        println!(include_str!("../LICENSE-CLAP"));
        std::process::exit(0);
    }

    let config = Conf {
        dither: if matches.is_present("dither") {
            value_t!(matches, "dither", u32).unwrap_or(10)
        } else {
            0
        },
        dry_run: matches.is_present("dry_run"),
        no_overwrites: matches.is_present("no_overwrites"),
    };
    if config.dither > 100 {
        println!("  ! Dither threshold probably set too high! False positives possible.")
    }


    if matches.is_present("INPUT") {
        // If a file name was given, process
        let input_fname = matches.value_of("INPUT").unwrap();
        match process_file(input_fname, &config) {
            Ok(_) => {}
            Err(err) => println!("{}", err.to_string()),
        }
    } else {
        // If no file name present, process all WAVs in current dir
        println!("No input file given. Processing current directory.");
        let current_dir = env::current_dir().unwrap();
        for dir_entry in read_dir(current_dir).expect("Can't read current directory") {
            match dir_entry.map(|entry| {
                // scan each directory entry, if accessible
                let path_str = entry.path().to_str().unwrap_or("").to_string(); //get path String
                validate_path(path_str.clone()).map(|_| {
                    // if it has wav extension
                    match process_file(&path_str, &config) {// process path
                        Ok(_) => Ok(()),
                        Err(err) => Err(err.to_string()),
                    }
                })
            }) {
                Ok(_) => {}
                Err(err) => println!("{}", err.to_string()),
            }
        }
    }
}

fn validate_u32(value: String) -> Result<(), String> {
    value.parse::<u32>()
         .map(|_| ())
         .map_err(|_| "Supplied parameter is not a valid number!".to_owned())
}

fn validate_path(path: String) -> Result<(), String> {
    if std::fs::metadata(&path).is_ok() {
        if path.to_lowercase().ends_with(".wav") {
            Ok(())
        } else {
            // clap automatically adds "error: " to the beginning of the message.
            Err(String::from("Input file must have .wav extension!"))
        }
    } else {
        Err(String::from("Input file doesn't exist"))
    }
}

fn read_file(fname: &str) -> Result<WavReader<std::io::BufReader<std::fs::File>>, String> {
    WavReader::open(fname).map_err(|err| err.to_string())
}

fn process_file(fname: &str, config: &Conf) -> Result<(), String> {
    println!("--- Analyzing: {}", fname);
    let reader = try!(read_file(fname));
    let spec = reader.spec();

    if spec.channels != 2 {
        return Err(String::from("File is not stereo! Exiting"));
    }
    if spec.sample_format == SampleFormat::Float {
        return Err(String::from("IEEE Float files are not supported! Exiting"));
    }

    if zero_test(reader, config.dither) {
        println!("\nFile is not double mono, channels are different!");
        Ok(())
    } else {
        println!("\nChannels are identical! Faux stereo detected");
        if !config.dry_run {
            try!(copy_to_mono(fname, &spec, config.no_overwrites));
        }
        Ok(())
    }
}

/// Check if data in each pair of samples is identical, or lies within given difference
fn zero_test<R: std::io::Read>(mut reader: WavReader<R>, dither_threshold: u32) -> bool {

    // Define a closure which compares the difference of two samples.
    // If dither_threshold is given, compare to it, else it must be 0
    let comparator: Box<Fn(i32) -> bool> = if dither_threshold == 0 {
        Box::new(|x: i32| x != 0)
    } else {
        Box::new(|x: i32| x.abs() as u32 > dither_threshold)
    };

    let dur_samples = reader.duration();
    let progress_chunk = dur_samples as u64 / 100;
    let progress_iter = (1..progress_chunk + 1).cycle();

    // println!("Duration in samples={},  Sample rate={}",reader.duration(),spec.sample_rate);

    // Initialize progress bar
    let mut pb = ProgressBar::new(dur_samples as u64);

    // Read pairs of samples, update progress bar each progress_chunk iteration.
    reader.samples::<i32>()
          .zip(progress_iter)
          .batching(|mut it| {
              match it.next() {
                  None => None,
                  Some(x) => {
                      match it.next() {
                          None => None,
                          Some(y) => {
                              if y.1 >= progress_chunk {
                                  pb.add(progress_chunk);
                              };
                              Some(x.0.unwrap() - y.0.unwrap())
                          }
                      }
                  }
              }
          })
          .any(|diff| comparator(diff))  //Actual comparison via closure
}

// Copy left channel of the input file to mono wav
fn copy_to_mono(input_fname: &str, spec: &WavSpec, no_overwrites: bool) -> Result<(), String> {
    println!("  * Converting to true-mono...");

    let new_spec = WavSpec {
        channels: 1,
        sample_rate: spec.sample_rate,
        bits_per_sample: spec.bits_per_sample,
        sample_format: spec.sample_format,
    };

    let mut reader = try!(read_file(input_fname));

    let output_path = Path::new(input_fname).with_extension("MONO.wav");
    if output_path.exists() {
        print!("Target file already exists. ");
        if no_overwrites {
            print!("Skipping.\n");
            return Ok(());
        } else {
            print!("Replacing...\n");
        };
    }

    let mut writer = try!(WavWriter::create(&output_path, new_spec).map_err(|err| err.to_string()));
    let mut error_occurred = false;
    match spec.bits_per_sample {
        8 => {
            for sample in reader.samples::<i8>().step(2) {
                if writer.write_sample(sample.unwrap()).is_err() {
                    error_occurred = true;
                    println!("Failed to write sample");
                    break;
                }
            }
        }
        16 => {
            for sample in reader.samples::<i16>().step(2) {
                if writer.write_sample(sample.unwrap()).is_err() {
                    error_occurred = true;
                    println!("Failed to write sample");
                    break;
                }
            }
        }
        24 | 32 => {
            match spec.sample_format {
                SampleFormat::Float => {
                    for sample in reader.samples::<f32>().step(2) {
                        if writer.write_sample(sample.unwrap()).is_err() {
                            error_occurred = true;
                            println!("Failed to write sample");
                            break;
                        }
                    }},
                SampleFormat::Int => {
                    for sample in reader.samples::<i32>().step(2) {
                        if writer.write_sample(sample.unwrap()).is_err() {
                            error_occurred = true;
                            println!("Failed to write sample");
                            break;
                        }
                    }}
            }
        }
        _ => {
            error_occurred = true;
            println!("Can't write a file! Unsupported sample rate requested!");
        }
    };
    if writer.finalize().is_err() {
        error_occurred = true;
        println!("Failed to finalize wav file");
    }

    // Cleaning up on write errors.
    if error_occurred {
        if remove_file(&output_path).is_err() {
            println!("Error removing created file, clean up manually.");
        }
        Err(format!("Failed writing \"{}\"", output_path.to_str().unwrap()))
    } else {
        println!("\"{}\" successfully written!",
            output_path.to_str().unwrap());
        Ok(())
    }
}

#[cfg(test)]

// TODO write tests
mod tests {
    #[test]
    fn test() {}
}
