extern crate clap;

use clap::{Arg, Command};
use std::fs;
use std::process;

static LICENSE: &str = "zrtstr licensed under GNU General Public License version 2 or later;
Full License available at <http://gnu.org/licenses/gpl.html>.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.";

pub struct Conf {
    pub dither: u32,
    pub dry_run: bool,
    pub no_overwrites: bool,
}

pub fn get() -> (Option<String>, Conf) {
    let matches = Command::new("zrtstr")
        .author(crate_authors!())
        .version(crate_version!())
        .about("Check stereo WAV-file for identical channels, detecting \
                faux-stereo files generated by some audio-editing software and \
                DAWs.\nOutputs a true-mono WAV file on detection of \
                faux-stereo. Takes left channel of the input file, writes in the \
                same location with -MONO suffix in file name.")
        .arg(Arg::new("INPUT")
                .help("Path to the input file to process. If no input given, \
                process all WAV files in current directory.")
                .index(1)
                .value_parser(validate_path))
        .arg(Arg::new("dither")
                .short('d')
                .long("dither")
                .value_name("THRESHOLD")
                .required(false)
                .help("Set threshold for sample level difference to process \
                        dithered audio.{n}Natural number (amplitude delta). Set to 0 for strict checking.")
                .next_line_help(true)
                .num_args(1)
                .default_missing_value("10")
                .default_value("10")
                .value_parser(clap::value_parser!(u32)))
        .arg(Arg::new("license")
                .short('l')
                .long("license")
                .action(clap::ArgAction::SetTrue)
                .help("Display the license information."))
        .arg(Arg::new("dry_run")
                .short('n')
                .long("nowrite")
                .action(clap::ArgAction::SetTrue)
                .help("Disable saving converted mono files. Analyze pass only.")
                .required(false))
        .arg(Arg::new("no_overwrites")
                .short('p')
                .long("protect")
                .action(clap::ArgAction::SetTrue)
                .help("Disable overwriting when saving converted mono files.")
                .required(false))
        .get_matches();

    if matches.get_flag("license") {
        println!("{}", LICENSE);
        println!("\nclap (Command Line Argument Parser) License:");
        println!(include_str!("../LICENSE-CLAP"));
        process::exit(0);
    }

    let conf = Conf {
        dither: *matches.get_one::<u32>("dither").unwrap(),
        dry_run: matches.get_flag("dry_run"),
        no_overwrites: matches.get_flag("no_overwrites"),
    };
    let input_fname = matches.get_one::<String>("INPUT").map(|s| s.to_string());

    (input_fname, conf)
}

pub fn validate_path(path: &str) -> Result<String, String> {
    if fs::metadata(path).is_ok() {
        if path.to_lowercase().ends_with(".wav") {
            Ok(path.to_string())
        } else {
            // clap automatically adds "error: " to the beginning of the message.
            Err(String::from("Input file must have .wav extension!"))
        }
    } else {
        Err(String::from("Input file doesn't exist"))
    }
}
