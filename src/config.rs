extern crate clap;

use clap::{Arg, App};
use std::fs;
use std::process;

static LICENSE: &'static str = "zrtstr licensed under GNU General Public License version 2 or later;
Full License available at <http://gnu.org/licenses/gpl.html>.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.";

pub struct Conf {
    pub dither: u32,
    pub dry_run: bool,
    pub no_overwrites: bool,
}

pub fn get() -> (Option<String>, Conf) {
    let matches = App::new("zrtstr")
        .author(crate_authors!())
        .version(crate_version!())
        .about("Check stereo WAV-file for identical channels, detecting \
                faux-stereo files generated by some audio-editing software and \
                DAWs.\nOutputs a true-mono WAV file on detection of \
                faux-stereo. Takes left channel of the input file, writes in the \
                same location with -MONO suffix in file name.")
        .arg(Arg::with_name("INPUT")
                .help("Path to the input file to process. If no input given, \
                process all WAV files in current directory.")
                .index(1)
                .validator(validate_path))
        .arg(Arg::with_name("dither")
                .short("d")
                .long("dither")
                .value_name("THRESHOLD")
                .required(false)
                .help("Set threshold for sample level difference to process \
                        dithered audio.{n}Positive number (amplitude delta).")
                .next_line_help(true)
                .takes_value(true)
                .default_value("10")
                .validator(validate_u32))
        .arg(Arg::with_name("license")
                .short("l")
                .long("license")
                .help("Display the license information."))
        .arg(Arg::with_name("dry_run")
                .short("n")
                .long("nowrite")
                .help("Disable saving converted mono files. Analyze pass only.")
                .required(false))
        .arg(Arg::with_name("no_overwrites")
                .short("p")
                .long("protect")
                .help("Disable overwriting when saving converted mono files.")
                .required(false))
        .get_matches();

    if matches.is_present("license") {
        println!("{}", LICENSE);
        println!("\nclap (Command Line Argument Parser) License:");
        println!(include_str!("../LICENSE-CLAP"));
        process::exit(0);
    }

    let conf = Conf {
        dither: if matches.is_present("dither") {
            value_t!(matches, "dither", u32).unwrap_or(10)
        } else {
            0
        },
        dry_run: matches.is_present("dry_run"),
        no_overwrites: matches.is_present("no_overwrites"),
    };
    let input_fname = if matches.is_present("INPUT") {
            Some(matches.value_of("INPUT").unwrap().to_string())
        } else {
            None
        };
    (input_fname, conf)
}

pub fn validate_u32(value: String) -> Result<(), String> {
    value.parse::<u32>()
         .map(|_| ())
         .map_err(|_| "Supplied parameter is not a valid number!".to_owned())
}

pub fn validate_path(path: String) -> Result<(), String> {
    if fs::metadata(&path).is_ok() {
        if path.to_lowercase().ends_with(".wav") {
            Ok(())
        } else {
            // clap automatically adds "error: " to the beginning of the message.
            Err(String::from("Input file must have .wav extension!"))
        }
    } else {
        Err(String::from("Input file doesn't exist"))
    }
}
